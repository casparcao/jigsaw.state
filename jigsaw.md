# 模块系统的说明

该文章是关于在[JSR 376: The Java Platform Module System](http://openjdk.java.net/projects/jigsaw/spec/)中提议的[Jigsaw](http://openjdk.java.net/projects/jigsaw/)项目原型的非正式版概览。[另一篇文章](http://openjdk.java.net/jeps/261)文章文章描述了JDK相关工具以及API的一些增强特性，不过这不在JSR的范围之内了。

就像[JSR376](http://openjdk.java.net/projects/jigsaw/spec/)中描述的一样，模块化系统的目标是提供：  

* 可靠的配置，用程序组件的方式来替代那脆弱的、易出错的classpath机制，并且可以显示的声明对其他组件的依赖。
* 强封装，允许组件声明哪些类型可以对其它组件开放，哪些不可以。

这些特性将会为应用开发者，库开发者，以及Java SE平台的实现人员带来直接跟间接的好处，因为开发者们可以使得系统具有更好的拓展性，更高的完整性，以及更高的性能。

### 目录

### 1. [定义模块](#1)  
[模块声明](#1.1).[模块组件](#1.2).[模块描述符](#1.3).[平台模块](#1.4)
### 2. [使用模块](#2)  
[模块路径](#2.1).[解析](#2.2).[可读性](#2.3).[可访问性](#2.4).[隐式可读性](#2.5)
### 3. [兼容性&迁移](#3)
[未命名的模块](#3.1).[自底向上的迁移](#3.2).[自动化模块](#3.3).[类路径的桥接](#3.4)
### 4. [服务](#4)
### 5. [高级话题](#5)
[映射](#5.1).[映射可读性](#5.2).[类加载器](#5.3).[未命名的模块](#5.4).[层](#5.5).[有限制的导出](#5.6)
### [总结](#6)
### [致谢](#7)

这是该文档的第二版，相比[最初版](http://openjdk.java.net/projects/jigsaw/spec/sotms/2015-09-08)，该版本介绍了[兼容性与迁移]()，修改了[映射可读性]()，重新编排文字，已改善叙述流程，并且分了两级以便于导航阅读。

目前的设计中依旧有很多[问题](http://openjdk.java.net/projects/jigsaw/spec/issues/)，他们的解决方案将会在该文档的未来版本中给予说明。

### <a name="1"></a>1 定义模块

为了能够在即对开发者友好，又能支持当前工具链的前提下，提供可靠的配置以及强封装性,我们把模块看作一种全新的Java基础程序组件。一个模块就是一个由代码跟数据组成的有名称的且自描述的集合。代码被组织为一个包含类型，如Java类跟接口的包的集合，而数据则包括资源或其他形式的静态信息。  

#### <a name="1.1"></a>1.1 模块声明  

一个模块的自描述性很好的体现在了它的`模块声明`上，一种Java编程语言中定义的新结构。一个可能的最简单的模块定义差不多只需要指定模块的名字即可：

```

module com.foo.bar { }  


```  
可以定义一个或多个`requires`语句来指定该模块在编译期以及运行时所依赖的其他模块的名字： 

```
module com.foo.bar {
    requires org.baz.qux;
}
```
最后，`exports`语句用来声明指定的包中的所有的，并且只有，`public`类型对其他模块可见：

```
module com.foo.bar {
    requires org.baz.qux;
    exports com.foo.bar.alpha;
    exports com.foo.bar.beta;
}
```
如果一个模块的声明中，不包含`exports`语句，则表明该模块不会对其他模块公开任何类型。  

按照约定，源码的模块定义被放在一个名为`module-info.java`的文件中，该文件位于源码层次结构的更目录下。com.foo.bar模块的源文件如下：

```
module-info.java
com/foo/bar/alpha/AlphaFactory.java
com/foo/bar/alpha/Alpha.java
...
```
按照约定，模块定义被编译到`module-info.class`文件中，同样会被放到类文件的输出目录中去。  

模块名称，就像包名称，必须不能有冲突。就像我们一直推荐的包取名的模式一样，我们推荐使用翻转域名的模式来给模块取名字。因此，通常模块的名字是导出包的名字的前缀，不过这种关系并不是强制性的。  

一个模块的定义不包含版本字符串，也不包含它所依赖的其他模块的版本号，这是有意为之的：解决版本选择问题并不是模块系统的[一个目标](http://openjdk.java.net/projects/jigsaw/spec/reqs/02#version-selection)，我们更倾向于将它留给构建工具或者容器来解决。  

由于一些原因，模块声明是Java编程语言的一部分，而不是一门自成体系的语言或符号，其中最重要的就是模块信息在编译期和运行时必须都可用，以达到跨阶段的高保真度，例如，确保模块系统在编译期跟运行时能以相同的方式工作，相应的，这就可以避免一些错误，或者至少能更早的报告错误--在编译期--可以更早的诊断然后修复。  

将源文件中的模块声明与模块中的其他源文件一起转换为Java虚拟机所需的类文件是建立保真度的一种常规手段。这种方式对于开发人员相当熟悉，并且对于IDE或者构建工具的支持也不困难。尤其是IDE，可以通过requires从组件的项目描述中已经提供的信息合成子句来为现有组件提供初始模块声明的建议。

#### <a name="1.2"></a>1.2 模块组件 

现有工具可以创建，操作和使用JAR文件，因此为了方便采用和迁移，我们定义了模块化的JAR文件。一个模块化的JAR文件就像普通的JAR文件一样，除了在根目录下还包含一个`module-info.class`文件。例如，上述`com.foo.bar`模块的jar文件中的内容可能像下面这样：
```
META-INF/
META-INF/MANIFEST.MF
module-info.class
com/foo/bar/alpha/AlphaFactory.class
com/foo/bar/alpha/Alpha.class
...
```
模块化JAR文件可以作为一个模块，在这种情况下，它的`module-info.class`文件被用来包含模块的声明。或者，可以把它放到普通的类路径中，这种情况下，它的`module-info.class`文件将被忽略。模块化JAR文件允许库的维护者既可以以工件的形式传输，来作为Java SE9 或者更高版本中的模块来使用，也可以作为适用于所有版本中类路径下的常规JAR文件。我们期望Java SE9的实现中包含一个增强的jar工具，可以很容易的创建模块化的JAR文件。  

为了模块化Java SE平台的参考实现，JDK，我们将引入一种新的工件格式，以适应本机代码，配置文件以及其他各种并不天生适配JAR文件的数据。这种格式利用了源文件中定义模块并编译到类文件中的另一个优势，即类文件跟其他任何特定的工件格式无关。这种新格式，暂时被叫做“JMOD”，它的标准名称至今是个悬而未决的问题。


#### <a name="1.3"></a>1.3 模块描述符  

将模块生命编译到类文件中还有一个最终的优势，就是类文件已经具备一种精确定义且可拓展的格式。因此在一个更广泛的意义上，我们可以将`module-info.class`作为**模块描述符**，其中包括源码级别的模块生命的编译格式，以及声明被初始编译后插入到类文件属性中的各种其他的信息。 

例如，IDE或者构建期的打包工具可以将包含像模块版本，标题，描述以及许可证等文档信息插入到属性中。可以通过模块系统的反射工具在编译期以及运行时来读取这些信息用来生成文档，诊断以及调试等。下游工具也可以使用它来构建特定于操作系统的程序包工件。将会有一系列特定的属性被标准化，但是，既然Java的类文件格式是可拓展的，那么其他的工具或者框架在必要的时候同样可以定义自己的属性。非标准的属性对模块系统本身不会造成影响。 

#### <a name="1.4"></a>1.4 平台模块  

Java SE 9 平台规范将使用模块系统把平台划分为一些裂模块。Java SE 9平台的实现可能包含所有的平台模块，也可能只包含其中的一部分。  

任何情况下，模块系统中唯一明确知道的模块是被叫做`java.base`的基模块。基模块定义并导出了所有的平台核心包，同样包括它自身:  
```
module java.base {
    exports java.io;
    exports java.lang;
    exports java.lang.annotation;
    exports java.lang.invoke;
    exports java.lang.module;
    exports java.lang.ref;
    exports java.lang.reflect;
    exports java.math;
    exports java.net;
    ...
}
```
基模块将会一直存在，任何其他模块都将隐式的依赖与基模块，然而基模块不会依赖于其他任何模块。  

其他的平台模块将使用`java.`前缀，并且可能包含像用来连接数据库的`java.sql`模块，用来处理XML的`java.xml`模块，以及日志处理的`java.logging`模块。Java SE 9平台规范中没有定义的模块，而在JDK中定义的模块，习惯上将会使用`jdk.`前缀。  

### <a name="2"></a>2 使用模块  

个人模块可以在模块工件中定义，也可以内置与编译期或者运行时环境中。为了在任意阶段都可以使用他们，模块系统需要定位它们，然后确定相互依赖关系，以便提供可靠的配置以及强封装性。  

#### <a name="2.1"></a>2.1 模块路径  

为了定位定义在工件中的模块，模块系统需要搜索主机中定义的`模块路径`。模块路径是一个序列，其中每个元素要么是模块工件，要么是包含模块工件的目录。模块系统会按顺序搜索模块路径中的元素去寻找第一个满足条件的模块。  

模块路径跟类路径有着本质上的区别，并且更加健壮强大。类路径天生的脆性是由于它只是定位所有工件中单个类型的手段，而不能区分工件本身的不同。这对于提前判断工件是否缺失尤其重要。它也允许不同的工件在相同的包中定义类型，即便这些工件是同一个程序组件的不同版本甚至是完全不同的组件。  

相反，模块路径是用来定位整个模块而不是单个类型的手段。如果模块系统无法在模块路径中找到某个特定的工件依赖，或者在同一个目录下遇到两个相同名称的工件，那么编译器或者虚拟机将会报告该错误并且退出。  

编译期或者运行时内置的模块，以及模块路径中定义的工件统称为`可观察到的模块`。

#### <a name="2.1"></a>2.2 解析  

假设我们有一个应用程序使用上面的com.foo.bar模块和平台的java.sql模块。包含应用程序核心的模块声明如下： 
```
module com.foo.app {
    requires com.foo.bar;
    requires java.sql;
}
```  
对于该初始应用模块，模块系统通过定位额外的可观察到的模块来解析`requires`语句中的依赖，然后再解析这些可观察到的模块的依赖，直到所有模块的所有依赖都得到解析。这种传递闭包计算的结果是形成一个`模块图`，对于每一个依赖其他模块的模块都包含一个从第一个模块到第二个模块的有向边。  

为了构建com.foo.app模块的模块图，模块系统会检查java.sql模块的声明：  
```
module java.sql {
    requires java.logging;
    requires java.xml;
    exports java.sql;
    exports javax.sql;
    exports javax.transaction.xa;
}
```  
同样会检查com.foo.bar模块的声明，以及org.baz.qux，java.logging，跟 java.xml模块。简单起见，最后三个并未包含提到，是因为他们并不包含对其他模块的依赖。  
![模块图](/images/2.2.png)

#### <a name="2.1"></a>2.3 可读性
#### <a name="2.1"></a>2.4 可访问性
#### <a name="2.1"></a>2.5 隐式可读性


### <a name="3"></a>3 兼容性&迁移
#### <a name="3.1"></a>3.1 未命名的模块
#### <a name="3.2"></a>3.2 自底向上的迁移
#### <a name="3.3"></a>3.3 自动化模块
#### <a name="3.4"></a>3.4 类路径桥接

### <a name="4"></a>4 服务

### <a name="5"></a>5 高级话题
#### <a name="5.1"></a>5.1 映射
#### <a name="5.2"></a>5.2 映射可读性
#### <a name="5.3"></a>5.3 类加载器 
#### <a name="5.4"></a>5.4 未命名的模块
#### <a name="5.5"></a>5.5 层
#### <a name="5.6"></a>5.6 有限制的导出

### <a name="6"></a>6 总结

### <a name="7"></a>7 致谢
