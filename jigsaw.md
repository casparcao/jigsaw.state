# 模块系统的说明

该文章是关于在[JSR 376: The Java Platform Module System](http://openjdk.java.net/projects/jigsaw/spec/)中提议的[Jigsaw](http://openjdk.java.net/projects/jigsaw/)项目原型的非正式版概览。[另一篇文章](http://openjdk.java.net/jeps/261)文章文章描述了JDK相关工具以及API的一些增强特性，不过这不在JSR的范围之内了。

就像[JSR376](http://openjdk.java.net/projects/jigsaw/spec/)中描述的一样，模块化系统的目标是提供：  

* 可靠的配置，用程序组件的方式来替代那脆弱的、易出错的classpath机制，并且可以显示的声明对其他组件的依赖。
* 强封装，允许组件声明哪些类型可以对其它组件开放，哪些不可以。

这些特性将会为应用开发者，库开发者，以及Java SE平台的实现人员带来直接跟间接的好处，因为开发者们可以使得系统具有更好的拓展性，更高的完整性，以及更高的性能。

### 目录

### 1. [定义模块](#1)  
[模块声明](#1.1).[模块组件](#1.2).[模块描述符](#1.3).[平台模块](#1.4)
### 2. [使用模块](#2)  
[模块路径](#2.1).[解析](#2.2).[可读性](#2.3).[可访问性](#2.4).[隐式可读性](#2.5)
### 3. [兼容性&迁移](#3)
[未命名的模块](#3.1).[由下而上的迁移](#3.2).[自动模块](#3.3).[类路径的桥接](#3.4)
### 4. [服务](#4)
### 5. [高级话题](#5)
[映射](#5.1).[映射可读性](#5.2).[类加载器](#5.3).[未命名的模块](#5.4).[层](#5.5).[有限制的导出](#5.6)
### [总结](#6)
### [致谢](#7)

这是该文档的第二版，相比[最初版](http://openjdk.java.net/projects/jigsaw/spec/sotms/2015-09-08)，该版本介绍了[兼容性与迁移]()，修改了[映射可读性]()，重新编排文字，已改善叙述流程，并且分了两级以便于导航阅读。

目前的设计中依旧有很多[问题](http://openjdk.java.net/projects/jigsaw/spec/issues/)，他们的解决方案将会在该文档的未来版本中给予说明。

### <a name="1"></a>1 定义模块

为了能够在即对开发者友好，又能支持当前工具链的前提下，提供可靠的配置以及强封装性,我们把模块看作一种全新的Java基础程序组件。一个模块就是一个由代码跟数据组成的有名称的且自描述的集合。代码被组织为一个包含类型，如Java类跟接口的包的集合，而数据则包括资源或其他形式的静态信息。  

#### <a name="1.1"></a>1.1 模块声明  

一个模块的自描述性很好的体现在了它的`模块声明`上，一种Java编程语言中定义的新结构。一个可能的最简单的模块定义差不多只需要指定模块的名字即可：

```

module com.foo.bar { }  


```  
可以定义一个或多个`requires`语句来指定该模块在编译期以及运行时所依赖的其他模块的名字： 

```
module com.foo.bar {
    requires org.baz.qux;
}
```
最后，`exports`语句用来声明指定的包中的所有的，并且只有，`public`类型对其他模块可见：

```
module com.foo.bar {
    requires org.baz.qux;
    exports com.foo.bar.alpha;
    exports com.foo.bar.beta;
}
```
如果一个模块的声明中，不包含`exports`语句，则表明该模块不会对其他模块公开任何类型。  

按照约定，源码的模块定义被放在一个名为`module-info.java`的文件中，该文件位于源码层次结构的更目录下。com.foo.bar模块的源文件如下：

```
module-info.java
com/foo/bar/alpha/AlphaFactory.java
com/foo/bar/alpha/Alpha.java
...
```
按照约定，模块定义被编译到`module-info.class`文件中，同样会被放到类文件的输出目录中去。  

模块名称，就像包名称，必须不能有冲突。就像我们一直推荐的包取名的模式一样，我们推荐使用翻转域名的模式来给模块取名字。因此，通常模块的名字是导出包的名字的前缀，不过这种关系并不是强制性的。  

一个模块的定义不包含版本字符串，也不包含它所依赖的其他模块的版本号，这是有意为之的：解决版本选择问题并不是模块系统的[一个目标](http://openjdk.java.net/projects/jigsaw/spec/reqs/02#version-selection)，我们更倾向于将它留给构建工具或者容器来解决。  

由于一些原因，模块声明是Java编程语言的一部分，而不是一门自成体系的语言或符号，其中最重要的就是模块信息在编译期和运行时必须都可用，以达到跨阶段的高保真度，例如，确保模块系统在编译期跟运行时能以相同的方式工作，相应的，这就可以避免一些错误，或者至少能更早的报告错误--在编译期--可以更早的诊断然后修复。  

将源文件中的模块声明与模块中的其他源文件一起转换为Java虚拟机所需的类文件是建立保真度的一种常规手段。这种方式对于开发人员相当熟悉，并且对于IDE或者构建工具的支持也不困难。尤其是IDE，可以通过requires从组件的项目描述中已经提供的信息合成子句来为现有组件提供初始模块声明的建议。

#### <a name="1.2"></a>1.2 模块组件 

现有工具可以创建，操作和使用JAR文件，因此为了方便采用和迁移，我们定义了模块化的JAR文件。一个模块化的JAR文件就像普通的JAR文件一样，除了在根目录下还包含一个`module-info.class`文件。例如，上述`com.foo.bar`模块的jar文件中的内容可能像下面这样：
```
META-INF/
META-INF/MANIFEST.MF
module-info.class
com/foo/bar/alpha/AlphaFactory.class
com/foo/bar/alpha/Alpha.class
...
```
模块化JAR文件可以作为一个模块，在这种情况下，它的`module-info.class`文件被用来包含模块的声明。或者，可以把它放到普通的类路径中，这种情况下，它的`module-info.class`文件将被忽略。模块化JAR文件允许库的维护者既可以以工件的形式传输，来作为Java SE9 或者更高版本中的模块来使用，也可以作为适用于所有版本中类路径下的常规JAR文件。我们期望Java SE9的实现中包含一个增强的jar工具，可以很容易的创建模块化的JAR文件。  

为了模块化Java SE平台的参考实现，JDK，我们将引入一种新的工件格式，以适应本机代码，配置文件以及其他各种并不天生适配JAR文件的数据。这种格式利用了源文件中定义模块并编译到类文件中的另一个优势，即类文件跟其他任何特定的工件格式无关。这种新格式，暂时被叫做“JMOD”，它的标准名称至今是个悬而未决的问题。


#### <a name="1.3"></a>1.3 模块描述符  

将模块生命编译到类文件中还有一个最终的优势，就是类文件已经具备一种精确定义且可拓展的格式。因此在一个更广泛的意义上，我们可以将`module-info.class`作为**模块描述符**，其中包括源码级别的模块生命的编译格式，以及声明被初始编译后插入到类文件属性中的各种其他的信息。 

例如，IDE或者构建期的打包工具可以将包含像模块版本，标题，描述以及许可证等文档信息插入到属性中。可以通过模块系统的反射工具在编译期以及运行时来读取这些信息用来生成文档，诊断以及调试等。下游工具也可以使用它来构建特定于操作系统的程序包工件。将会有一系列特定的属性被标准化，但是，既然Java的类文件格式是可拓展的，那么其他的工具或者框架在必要的时候同样可以定义自己的属性。非标准的属性对模块系统本身不会造成影响。 

#### <a name="1.4"></a>1.4 平台模块  

Java SE 9 平台规范将使用模块系统把平台划分为一些裂模块。Java SE 9平台的实现可能包含所有的平台模块，也可能只包含其中的一部分。  

任何情况下，模块系统中唯一明确知道的模块是被叫做`java.base`的基模块。基模块定义并导出了所有的平台核心包，同样包括它自身:  
```
module java.base {
    exports java.io;
    exports java.lang;
    exports java.lang.annotation;
    exports java.lang.invoke;
    exports java.lang.module;
    exports java.lang.ref;
    exports java.lang.reflect;
    exports java.math;
    exports java.net;
    ...
}
```
基模块将会一直存在，任何其他模块都将隐式的依赖与基模块，然而基模块不会依赖于其他任何模块。  

其他的平台模块将使用`java.`前缀，并且可能包含像用来连接数据库的`java.sql`模块，用来处理XML的`java.xml`模块，以及日志处理的`java.logging`模块。Java SE 9平台规范中没有定义的模块，而在JDK中定义的模块，习惯上将会使用`jdk.`前缀。  

### <a name="2"></a>2 使用模块  

个人模块可以在模块工件中定义，也可以内置与编译期或者运行时环境中。为了在任意阶段都可以使用他们，模块系统需要定位它们，然后确定相互依赖关系，以便提供可靠的配置以及强封装性。  

#### <a name="2.1"></a>2.1 模块路径  

为了定位定义在工件中的模块，模块系统需要搜索主机中定义的`模块路径`。模块路径是一个序列，其中每个元素要么是模块工件，要么是包含模块工件的目录。模块系统会按顺序搜索模块路径中的元素去寻找第一个满足条件的模块。  

模块路径跟类路径有着本质上的区别，并且更加健壮强大。类路径天生的脆性是由于它只是定位所有工件中单个类型的手段，而不能区分工件本身的不同。这对于提前判断工件是否缺失尤其重要。它也允许不同的工件在相同的包中定义类型，即便这些工件是同一个程序组件的不同版本甚至是完全不同的组件。  

相反，模块路径是用来定位整个模块而不是单个类型的手段。如果模块系统无法在模块路径中找到某个特定的工件依赖，或者在同一个目录下遇到两个相同名称的工件，那么编译器或者虚拟机将会报告该错误并且退出。  

编译期或者运行时内置的模块，以及模块路径中定义的工件统称为`可观察到的模块`。

#### <a name="2.1"></a>2.2 解析  

假设我们有一个应用程序使用上面的com.foo.bar模块和平台的java.sql模块。包含应用程序核心的模块声明如下： 
```
module com.foo.app {
    requires com.foo.bar;
    requires java.sql;
}
```  
对于该初始应用模块，模块系统通过定位额外的可观察到的模块来解析`requires`语句中的依赖，然后再解析这些可观察到的模块的依赖，直到所有模块的所有依赖都得到解析。这种传递闭包计算的结果是形成一个`模块图`，对于每一个依赖其他模块的模块都包含一个从第一个模块到第二个模块的有向边。  

为了构建com.foo.app模块的模块图，模块系统会检查java.sql模块的声明：  
```
module java.sql {
    requires java.logging;
    requires java.xml;
    exports java.sql;
    exports javax.sql;
    exports javax.transaction.xa;
}
```  
同样会检查com.foo.bar模块的声明，以及org.baz.qux，java.logging，跟 java.xml模块。简单起见，最后三个并未包含提到，是因为他们并不包含对其他模块的依赖。  

基于所有这些模块声明，com.foo.app模块的模块图应该包含以下节点跟有向边：  

![模块图](/images/2.2.png)  

该图中深蓝色的线表示`requires`语句中表明的显示的依赖关系，而浅蓝色的线表示每个模块对基模块的隐式的依赖。  

#### <a name="2.3"></a>2.3 可读性  

当模块图中的一个模块直接依赖其他模块时，那么第一个模块中的代码将可以引用第二个模块中的类型。因此我们说第一个模块`读取`第二个模块，或者等价的说，第二个模块对第一个模块是`可读的`。因此，在上面的图中，com.foo.app模块可以读取com.foo.bar以及java.sql模块，但是无法读取org.baz.qux，java.xml，以及java.logging模块。java.logging模块对于java.sql模块是可读的，但对其他模块不可读。（根据定义，任何模块对自己是可读的)  

模块图中定义的可读性关系是可靠配置的基础：模块系统确保对每一个其他模块依赖的精确匹配，保证模块图是无回路的，每一个模块最多读取一个给定包的模块，以及定义相同包名的模块互不影响。  

可靠的配置不仅更可靠，而且更快。当一个模块中的代码引用某个包中的类型时，该包会被确定定义在了该模块中，或者该模块可读的其他模块中。因此当搜索某个具体的类型时就没有必要搜索多个模块，甚至更糟的去搜索整个类路径。  

#### <a name="2.1"></a>2.4 可访问性  

模块图中定义的可读性关系以及模块声明中的`exports`语句是强封装性的基础。Java编译器跟虚拟机认为一个模块的某个包中的公共类型对其他模块中的代码是`可访问性`的条件是第一个模块对第二个模块是可读的，并且第一个模块导出了那个包。比如，两个类型S跟T定义在两个不同的模块中，并且T是公共的，那么S可以访问T的条件是：  
1. S所在模块可读去T所在模块，并且  
2. T所在模块导出了T所在的包。  

就像私有方法跟域不可用一样，透过模块边界不可访问的类型是不可用的。任何尝试访问都会得到一个编译器报告的错误，或者虚拟机抛出的`IllegalAccessError`，或者反射运行时API抛出的`IllegalAccessException`。因此即使当一个类型被定义为公共的，但是假如它所在的包没有在模块声明中被导出，那么它也只能对本模块内的代码访问。  

如果一个方法或者域的外围类是可以访问的，并且该成员本身的声明也是允许访问的，那么它也可以透过模块边界被访问。  

来看一下上面的模块图中的强封装性是如何工作的，我们给每个模块贴上它所导出的包的标签：  

![强封装性](/images/2.4.png)  

模块com.foo.app模块中的代码可以访问com.foo.bar.alpah包中的公共类型，因为com.foo.app依赖于它，因此可读取com.foo.bar模块，并且com.foo.bar模块导出了com.foo.bar.alpah包。 如com.foo.bar包含一个内部包com.foo.bar.internal，那么com.foo.app中的代码不能访问该包中的任何类型，因为com.foo.bar没有导出它。com.foo.app中的代码不能访问org.baz.qux包中的类型，因为coom.foo.app不依赖它，因此不可读去该模块。  

#### <a name="2.1"></a>2.5 隐式可读性  

如果一个模块可以读取另一个模块，某些情况，逻辑上也应该可以读取其他模块。  

例如，平台的java.sql模块依赖java.logging跟java.xml模块，不仅因为它的代码实现中使用了这些模块中的类型，而且还因为它定义了方法签名引用了这些模块中的类型的类型。 java.sql.Driver接口中声明了下面这个公共方法：  

```
public Logger getParentLogger();
```

其中Logger是java.logging模块中导出的java.util.logging包中声明的类型。  

假设，com.foo.app模块中的代码为了获取logger并且记录日志而调取了这个方法：  

```
String url = ...;
Properties props = ...;
Driver d = DriverManager.getDriver(url);
Connection c = d.connect(url, props);
d.getParentLogger().info("Connection acquired");
```  

如果com.foo.app模块的声明像上面提到的那样，那么这段代码将不能工作：getParentLogger方法返回一个Logger，它是一个在java.logging模块中声明的类型，它对com.foo.app模块是不可读的，因此上面对Logger类中的info方法的调用在编译期跟运行时都将失败，因为该类不可访问，所以该方法同样不可访问。  

该问题的一个解决方案是所有依赖java.sql模块并且包含使用getParentLogger方法返回的Logger对象的代码的模块作者记得声明一个对java.logging模块的依赖。当然这种方式是不可靠的，因为它打破了最少意外的原则：如果一个模块依赖第二个模块，那么很自然的希望每个需要使用第一个模块的类型，即使是在第二个模块中定义的类型，都将对于仅仅依赖第一个模块的模块是直接可访问的。  

因此我们拓展模块的声明以便一个模块可以将它所依赖的其他模块的可读性授予依赖它的任何模块。这种`隐式的可读性`通过在`requires`语句中包含一个public修饰符来表达。java.sql模块的声明实际上是这样：  

```
module java.sql {
    requires public java.logging;
    requires public java.xml;
    exports java.sql;
    exports javax.sql;
    exports javax.transaction.xa;
}
```  
public修饰符意味着任何依赖java.sql的模块不仅可读取java.sql模块，而且也可以读取java.logging跟java.xml模块。因此com.foo.app模块的模块图将包含两条用绿色边连接到java.sql模块的深蓝色的边，因为它们是因该模块而隐式可读的：  

![隐式可读](/images/2.5.png)  

现在com.foo.app模块可以包含访问java.logging及java.xml模块导出包中所有公共类型的代码了，即使它的声明中没有提到这两个模块。  

通常，如果一个模块导出一个包，该包包含一个签名引用第二个模块的类型，那么第一个模块的声明应该包含一个对第二个模块的`requires public`依赖。这样可以确保其它依赖第一个模块的模块自动的对第二个模块具有可读性，以及可以访问该模块导出包中的所有公共类型。  

### <a name="3"></a>3 兼容性&迁移  

到目前为止，我们已经看到了如何从头开始定义模块，将它们打包成模块工件，并且把他们与其他平台内置的模块或者定义在其他工件中的模块一起使用。  

当然，大部分的Java代码是在模块系统引入前就写好的，并且还必须像现在这样不需任何改变依旧能正常运行。因此，即使平台本身是由模块组成，模块系统也仍然可以编译运行由类路径中的Jar文件组成的应用。并且也可以将先用的应用以一种灵活渐进的方式迁移到模块化中来。  

#### <a name="3.1"></a>3.1 未命名模块  

如果有个需求是在任意已知的模块中加载一个没有定义包的类型，那么模块系统会尝试从类路径中加载它。如果加载成功，那么会被认为是一个特殊的被称为`未命名模块`的成员，以便确保每个类型关联到某个模块上。未命名模块就像是高级层面上的现有的[未命名包](http://docs.oracle.com/javase/specs/jls/se8/html/jls-7.html#jls-7.4.2)的概念。当然，以后我们就把那些有名称的模块称作`命名的模块`。   

未命名的模块可以读取其他任意模块。因此从类路径中加载的任意类型中的代码都将可以访问任意其他可读模块的导出类型，这些可读模块默认包括命名模块，内置的平台模块。因此，在Java SE 8上编译和运行的现有类路径应用程序将在Java SE 9上以完全相同的方式进行编译和运行，只要它只使用了标准的，不被废弃的Java SE API即可。  

未命名模块会导出它的所有包。就像我们将在下面看到的，这会使得迁移更加灵活。然而，这不意味着命名模块中的代码可以访问未命名模块中的类型。事实上，命名模块甚至不能声明对未命名模块的依赖。这个限制是有意为之的。因为允许命名模块依赖类路径中的任意内容是不可能做到可靠的配置的。  

如果一个包被定义在了命名模块跟未命名模块中，那么未命名模块中的包会被忽略。即使面对类路径的混乱这依旧保持可靠的配置，即确保每一个模块依旧最多只会读取一个定义特定包的模块。如果在我们上面的例子中，一个类路径下的JAR文件包含com/foo/bar/alpha/AlphaFactory.class类，那么该文件将永远不会被加载，因为com.foo.bar.alpha包是com.foo.bar模块的导出包。  

#### <a name="3.2"></a>3.2 由下而上的迁移  

把从类路径中加载的类型当作未命名模块的成员允许我们以增量，自下而上的方式将现有应用程序的组件从JAR文件迁移到模块。  

假设，上面提到的应用最初是在Java SE 8下构建的，作为放在类路径下的一组类似命名的JAR文件。如果我们按原样在Java SE 9中运行它们，那么这些JAR文件中的所有类型都会被定义到未命名模块中。该模块可以读取所有其他模块，包括所有内置的平台模块，简单起见，假设只讨论前面提到的java.sql，java.xml，java.logging，以及java.base模块，因为我们得到如下模块图：  

![迁移](/images/3.2.1.png)  

我们可以直接将org-bar-qux.jar转化为命名模块，因为我们知道它不会引用其它两个JAR文件中的任何类型，所以，作为一个命名模块，它不会引用任何被留在未命名模块中的类型。（我们碰巧从最初的例子中知道这点，但是如果我们还不知道，那么我们可以使用[jdeps]()）我们写一个org.baz.qux的模块声明，并把它添加到模块的源码中，然后编译它，并将结果打包成一个模块JAR文件。如果我们把这个JAR文件放到模块路径中，并且把其它的留在类路径中，我们会得到如下增强的模块图：  

![迁移增强](/images/3.2.2.png)   

com-foo-bar.jar和com-foo-app.jar中的代码可以继续工作，因为未命名模块可以读取任意命名模块，包括新的org.baz.qux模块。  

我们可以用相似的方式处理com-foo-bar.jar以及com-foo-app.jar，最终重新绘制前面显示的模块图：  

![最终模块图](/images/3.2.3.png)  

我们知道对原始的JAR文件中的类做了什么，当然可以一步就将三个应用模块化。然而，如果org-baz-qux.jar是由一个完全不同的团队或者组织单独维护的，那么它可以在其他两个组件之前被模块化，同样com-foo-bar.jar可以在com-foo-app.jar之前被模块化。  

#### <a name="3.3"></a>3.3 自动模块  

自下而上的迁移是直截了当的，当并不可能总是如此。即使org-baz-qux.jar的维护者还没有将它转化为合适的模块-或者永远不会将它模块化-我们依旧想模块化我们自己的com-foo-app.jar和com-foo-bar.jar组件。  

我们已经知道com-foo-bar.jar中的代码引用org-baz-qux.jar中的类型。如果我们把com-foo-bar.jar转换为命名模块com.foo.bar，但是把org-baz-qux.jar留在类路径中，那么会导致代码不可用：org-baz-qux.jar中的类型会被定义到未命名模块中，而com.boo.bar是命名模块，是无法依赖于未命名模块的。  

因此我们必须以某种方式让org-baz-qux.jar以命名模块的方式运行，以便com.foo.bar可以依赖它。我们可以fork一个org.baz.qux源码的分支然后我们自己将其模块化，但是维护者不愿将它合并到上游仓库中，那么就不得不一直维护这个分支。  

相反，我们可以将org-baz-qux.jar作为一个`自动模块`，原封不动的将其放到模块路径中而不是类路径下。这样将会定义一个可观察的模块，它的名字将由JAR文件衍生而来`org.baz.qux`，以便非自动模块可以用常规的方式依赖它：  

![自动模块0](/images/3.3.1.png)  

自动模块是一个隐式定义的命名模块，因为它没有模块声明。相比之下，一个普通的命名模块会有模块声明来显示的定义；我们以后把这类模块看作显示模块。  

没有好办法可以提前告知自动模块可能依赖哪些其他模块。因此在一个模块图被确定之后，自动模块可以读取任意其他的命名模块，无论自动还是显示：  

![自动模块1](/images/3.3.2.png) 

（这些新的可读性边确实在模块图中造成了回路，使得它有些更加难懂了，但是我们把这看作是更加灵活迁移的可容忍的结果。）  

类似的，没有好的办法去判断一个自动模块中的包会被其他模块或者仍在类路径中的类使用。因此，自动模块中的每个包都会被导出，即使实际上它只被内部使用：  

![自动模块2](/images/3.3.3.png)  

最后，没有好的办法判断自动模块中是否有导出包中包含某些类型，它的方法签名中引用了其他自动模块中的类型。例如，我们首先模块化com.foo.app。并且将com.foo.bar和org.baz.qux都当作自动模块，那么我们将会得到下面模块图：  

![自动模块3](/images/3.3.4.png)  

不读取相关的JAR文件中的所有类文件，是不能知道com.foo.bar中的公共类型是否声明了一个返回类型是org.baz.qux中的公共方法。因此，自动模块被授予对其它所有自动模块的隐式可读性：  

![自动模块4](/images/3.3.5.png)  

现在，com.foo.app中的代码可以访问org.baz.qux中的类型，尽管我们知道实际上并不是这么做的。  

自动模块提供了一个类路径的混乱与显示模块的严格的中间方案。就像上面看到的，他们允许一个由JAR文件组成的现有应用可以以自上而下，或者结合自上而下与自下而上的方式迁移到模块化中来。一般来讲，我们从一组任意类路径下的JAR文件组件开始，使用jdeps工具来分析他们的相互依赖，将那些我们可以控制源码的组件转换为显示模块，并且与剩余的JAR文件一起放到模块路径下。那些不能控制源码的JAR文件组建会被当作自动模块直到有一天他们也被转换为显示模块。  

#### <a name="3.4"></a>3.4 类路径桥接

### <a name="4"></a>4 服务

### <a name="5"></a>5 高级话题
#### <a name="5.1"></a>5.1 映射
#### <a name="5.2"></a>5.2 映射可读性
#### <a name="5.3"></a>5.3 类加载器 
#### <a name="5.4"></a>5.4 未命名的模块
#### <a name="5.5"></a>5.5 层
#### <a name="5.6"></a>5.6 有限制的导出

### <a name="6"></a>6 总结

### <a name="7"></a>7 致谢
